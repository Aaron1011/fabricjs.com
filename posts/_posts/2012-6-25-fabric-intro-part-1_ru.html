---
layout: article
title: Introduction to Fabric.js. Part 1.
---

<style>h2 { margin-bottom: 15px } h3 { margin-bottom: 10px; } h4 { margin-bottom: 7px; } </style>

<div class="container" style="margin:30px auto">
  <h2 id="introduction_to_fabricjs">Знакомимся с Fabric.js. Часть 1-я.</h2>

  <img src="https://github.com/kangax/fabric.js/raw/master/lib/screenshot.png" style="width:300px;border:1px solid #ccc;margin-bottom:20px">

  <p>Сегодня я хочу познакомить вас с <a href="http://fabricjs.com">Fabric.js</a> &mdash; мощной Javascript библиотекой для работы с <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html">HTML5 &lt;canvas></a>. Fabric включает в себя обектную модель — которой так не хватает при работе с &lt;canvas>, а так же SVG парсер, интерактивный слой, и множество других незаменимых инструментов. Это полностью открытая библиотека, с MIT лицензией и многими взносами разработчиков за последние несколько лет.</p>

  <p>Работу над Fabric я начал 3 года назад, когда понял насколько тяжело работать с обычным canvas API. В тот момент я создавал интерактивный редактор на <a href="http://printio.ru">printio.ru</a> &mdash; мой стартап, где мы даём возможность создать дизайн и напечатать его на одежде или других товарах. Редактор хотелось сделать удобным и супер интерактивным. В то время, такой функционал можно было создать только во Flash. Но Flash использовать я не хотел. Люблю Javascript и был уверен что с ним можно добиться много. Получилось довольно неплохо :) Даже сейчас очень немногие визуальные редакторы могут делать то что можно достичь с помощью Fabric.</p>

  <p>Ну что ж, давайте посмотрим поближе!</p>

  <h3 id="why_fabric">Зачем это нужно?</h3>

  <p>В последнее время, с <a href="http://http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html">Canvas</a> создают <a href="http://net.tutsplus.com/articles/web-roundups/21-ridiculously-impressive-html5-canvas-experiments/">довольно</a> <a href="http://speckyboy.com/2011/12/07/20-amazing-implementations-of-html5-canvas/">поразительные</a> <a href="http://artatm.com/2012/01/23-truly-amazing-and-unbelievable-html5-canvas-and-javascript-experiments/">вещи</a>. Но родное canvas API <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#2dcontext">ужасно низко-уровневое</a>. Одно дело если нужно нарисовать несколько простых фигур или графиков, и забыть о них. Но как только появляется необходимость в интерактивности, изменении картинки в какой-то момент, или рисовании более сложных фигур — ситуация становится довольно печальной.</p>

  <p>Вот именно для этого и нужна Fabric.</p>

  <p>Дело в том, что обычные canvas методы позволяют нам вызывать только очень простые графические комманды, в слепую меняя целый битмап холста (canvas). Нужно нарисовать прямоугольник? Используем <code>fillRect(left, top, width, height)</code>. Нарисовать линию? Используем комбинацию <code>moveTo(left, top)</code> и <code>lineTo(x, y)</code>. Как будто рисуем <strong>кисточкой по холсту</strong>, накладывая всё больше и больше краски на холст, почти без какого либо контроля.</p>

  <p>Fabric даёт нам объектную модель поверх низко-уревневых методов canvas, хранит состояние холста, и позволяет работать с "обьектами" напрямую.</p>

  <p>Давайте посмотрим на разницу между canvas и Fabric. Допустим, нужно нарисовать красный прямоугольник. Используя canvas API, это делается прилизительно так:</p>

<pre>
// берём canvas элемент (id="c")
var canvasEl = document.getElementById('c');

// берём 2d контекст на котором рисовать ("bitmap" упомянутый ранее)
var ctx = canvasEl.getContext('2d');

// меняем fill (закраску) цвета контекста
ctx.fillStyle = 'red';

// создаём прямоугольник в точке 100,100 размером в 20x20
ctx.fillRect(100, 100, 20, 20);
</pre>

  <p>А вот тоже самое с Fabric:</p>

<pre>
// создаём "оболочку" вокруг canvas элемента (id="c")
var canvas = new fabric.Canvas('c');

// создаём прямоугольник
var rect = new fabric.Rect({
  left: 100,
  top: 100,
  fill: 'red',
  width: 20,
  height: 20
});

// "добавляем" прямоугольник чтобы он отобразился
canvas.add(rect);
</pre>

  <p><img src="/article_assets/1.png"></p>

  <p>Разницы в размере кода пока не видно. Однако видно что способ работы с canvas кардинально отличается. В обычном canvas API, мы <strong>работаем с контекстом</strong> &mdash; объект который по сути дела представляет из себя битмап холста. С Fabric, мы <strong>управляем именно объектами</strong> &mdash; создаём, меняем параметры, добавляем их на canvas. Как видите, эти объекты — полноценные жители в Fabric (объекты первого класса).</p>

  <p>Рисовать красный прямоугольник — это конечно не серьёзно. Давайте хоть сделаем с ним что-нибудь интересное. Например, повернём на 45 градусов.</p>

  <p>Сначала используя обычные методы:</p>

<pre>
var canvasEl = document.getElementById('c');
var ctx = canvasEl.getContext('2d');
ctx.fillStyle = 'red';

<b>ctx.translate(100, 100);
ctx.rotate(Math.PI / 180 * 45);
ctx.fillRect(-10, -10, 20, 20);</b>
</pre>

  <p>и теперь с помощью Fabric:</p>

<pre>
var canvas = new fabric.Canvas('c');

// создаём прямоугольник с углом в 45 градусов
var rect = new fabric.Rect({
  left: 100,
  top: 100,
  fill: 'red',
  width: 20,
  height: 20,
  <b>angle: 45</b>
});

canvas.add(rect);
</pre>

  <p><img src="/article_assets/2.png"></p>

  <p>Что здесь происходит?</p>

  <p>Используя Fabric, всё что надо было сделать это поменять значение угла на <code>45</code>. А вот с обычными методами всё не так-то просто. Во первых, ме не можем управлять объектами напрямую. Вместо этого, приходится менять позицию и угол самого битмапа (<code>ctx.translate</code>, <code>ctx.rotate</code>). Потом рисуем прямоугольник, при этом не забывая отодвинуть битмап соответственно (-10, -10), так чтобы прямоугольник появился на 100,100. И ещё надо не забыть перевести угол из градусов в радианы при повороте битмапа.</p>

  <p>Теперь вам наверное становится понятно зачем существует Fabric.</p>

  <p>Но давайте посмотрим на ещё один пример — хранение состояния canvas.</p>

  <p>Что если в какой-то момент нам нужно подвинуть этот красный прямоугольник в другое место? Как это сделать не имея возможность управлять объектами? Наверное придётся вызывать <code>fillRect</code> ещё раз?</p>

  <p>Не совсем. Вызывая ещё одну команду <code>fillRect</code>, прямоугольник рисуется прямо поверх всего битмапа. Именно поэтому я привёл аналог кисти с краской. Чтобы подвинуть фигуру, нам нужно сначала <strong>стереть предыдущий результат</strong>, а потом уже рисовать на новом месте.</p>

<pre>
var canvasEl = document.getElementById('c');

...
ctx.strokRect(100, 100, 20, 20);
...

// стираем весь canvas
<b>ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
ctx.fillRect(20, 50, 20, 20);</b>
</pre>

  <p>Ну а что насчёт Fabric?</p>

<pre>
var canvas = new fabric.Canvas('c');
...
canvas.add(rect);
...

<b>rect.set({ left: 20, top: 50 });
canvas.renderAll();</b>
</pre>

  <p><img src="/article_assets/3.png"></p>

  <p>Заметьте очень важную разницу. Нам не пришлось абсолютно ничего стирать перед рисованием. Просто продолжаем работать с объектами, меняя их атрибуты, а потом перерисовываем canvas чтобы увидеть изменения. Таким образом можно изменить десятки объектов, и потом одной командой обновить экран.</p>

  <h3 id="objects">Объекты</h3>

  <p>Мы уже видели как работать с прямоугольниками, используя <code>fabric.Rect</code> конструктор. Но конечно же Fabric предоставляет многие другие простые фигуры &mdash; круги, треугольники, эллипсы, и т.д. Все они доступны из <code>fabric</code> объекта как <code>fabric.Circle</code>, <code>fabric.Triangle</code>, <code>fabric.Ellipse</code>, и т.д.</p>

  <p>7 базовых фигур доступных в Fabric:</p>

  <ul>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Circle.html">fabric.Circle</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Ellipse.html">fabric.Ellipse</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Line.html">fabric.Line</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Polygon.html">fabric.Polygon</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Polyline.html">fabric.Polyline</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Rect.html">fabric.Rect</a></li>
  <li><a href="http://fabricjs.com/docs/symbols/fabric.Triangle.html">fabric.Triangle</a></li>
  </ul>

  <p>Нужно нарисовать круг? Просто создаём соответствующий объект и добавляем его на холст. Тоже самое с другими формами:</p>

<pre>
var circle = new fabric.Circle({
  radius: 20, fill: 'green', left: 100, top: 100
});
var triangle = new fabric.Triangle({
  width: 20, height: 30, fill: 'blue', left: 50, top: 50
});

canvas.add(circle, triangle);
</pre>

  <p><img src="/article_assets/4.png"></p>

  <p>..и вот уже на холсте красуются зелёный круг в точке 100, 100, и синий треугольник в точке 50, 50.</p>

  <h4 id="manipulating_objects">Управляем объектами</h4>

  <p>Создание визуальных фигур — это только цветочки. В какой-то момент, наверняка понадобится их менять. Возможно какие-то действия пользователя должны сказываться на состоянии картинки (холста), или должна быть запущена анимация. Или же нужно поменять атрибуты объектов (цвет, прозрачность, размер, позицию) от движений мышки.</p>

  <p>Fabric берёт на себя заботу о состоянии холста и перерисовке. От нас требуется только менять сами объекты.</p>

  <p>В предыдущем примере было видно как метод <code>set</code> подвинул объект на новую позицию <code>set({ left: 20, top: 50 })</code>. Точно также можно менять любые другие аттрибуты. А что доступно?</p>

  <p>Во первых, атрибуты меняющие позицию &mdash; <strong>left</strong>, <strong>top</strong>; размер &mdash; <strong>width</strong>, <strong>height</strong>; сам рендеринг (отображение объекта) &mdash; <strong>fill</strong>, <strong>opacity</strong>, <strong>stroke</strong>, <strong>strokeWidth</strong>; масштаб и поворот &mdash; <strong>scaleX</strong>, <strong>scaleY</strong>, <strong>angle</strong>; и даже переворот (180 градусов) &mdash; <strong>flipX</strong>, <strong>flipY</strong>.</p>

  <p>Да, отобразить зеркально повёрнутую картинку в Fabric на удивление легко — просто выставляем flip* аттрибут как <code>true</code>.</p>

  <p>Чтение аттрибутов происходит через метод <code>get</code>, присваивание — через <code>set</code>. Давайте как-нибудь поменяем всё тот же прямоугольник:</p>

<pre>
var canvas = new fabric.Canvas('c');
...
canvas.add(rect);

rect.set('fill', 'red');
rect.set({ strokeWidth: 5, stroke: 'rgba(100,200,200,0.5)' });
rect.set('angle', 15).set('flipY', true);
</pre>

  <p><img src="/article_assets/5.png"></p>

  <p>Сначала выставляем &#8220;fill&#8221; как &#8220;red&#8221;, меняя цвет объекта на красный. Затем меняем оба &#8220;strokeWidth&#8221; и &#8220;stroke&#8221;, что придаёт прямоугольнику 5px рамку светло-зелёного цвета. И наконец, меняем &#8220;angle&#8221; и &#8220;flipY&#8221; аттрибуты. Заметьте как 3 выражения используют слегка разный синтакс.</p>

  <p>Это показывает что <code>set()</code> — довольно универсальный метод. Так как используется часто, он сделан как можно удобней.</p>

  <p>Ну а что насчёт чтения? Как я уже упомянул, есть общий <code>get()</code>, а также набор конкретных <code>get*()</code> методов. Например, для получение &#8220;width&#8221; объекта, можно использовать <code>get('width')</code> или <code>getWidth()</code>. Для &#8220;scaleX&#8221; &mdash; <code>get('scaleX')</code> или <code>getScaleX()</code>, и т.д. Такие специальные методы как <code>getWidth()</code> и <code>getScaleX()</code> существуют для каждого &#8220;публичного&#8221; атрибута объекта (&#8220;stroke&#8221;, &#8220;strokeWidth&#8221;, &#8220;angle&#8221;, и т.д.)</p>

  <p>Вы наверное заметили, что в предыдущих примерах были использованы конфигурационные хэши, которые выглядели точно также как и те которые мы только что что использовали в <code>set</code> методе. Это потомо что они действительно <strong>одинаковые</strong>. Объект может быть "сконфигурирован" или в момент создания, или позже с помощью метода <code>set</code>. И синтакс абсолютно одинаковый:</p>

<pre>
var rect = new fabric.Rect({ width: 10, height: 20, fill: '#f55', opacity: 0.7 });

// полностью идентичен

var rect = new fabric.Rect();
rect.set({ width: 10, height: 20, fill: '#f55', opacity: 0.7 });
</pre>

  <h4 id="default_options">Атрибуты по умолчанию</h4>

  <p>Возможно вы задаётесь вопросом &mdash; что же происходит с объектом когда создаём его без конфигурационного хэша. У него всё равно имеются все обычные атрибуты?</p>

  <p>Несомненно. У всех объектов в Fabric всегда есть набор значений по умолчанию. Именно они и используются когда во время создания мы не задаём другие значения. Давайте попробуем сами:</p>

<pre>
var rect = new fabric.Rect(); // notice no options passed in

rect.getWidth(); // 0
rect.getHeight(); // 0

rect.getLeft(); // 0
rect.getTop(); // 0

rect.getFill(); // rgb(0,0,0)
rect.getStroke(); // null

rect.getOpacity(); // 1
</pre>

  <p>Прямоугольник получил значения по умолчанию. Он находится в позиции 0,0, чёрного цвета, полностью непрорзрачный, не имеет рамок и <strong>габаритов</strong> (ширина и высота равны 0). Из за отсутствия габаритов, мы не видим его на холсте. Но как только присваиваем width/height позитивное значение — чёрный прямоугольник появляется в левом верхнем углу.</p>

  <p><img src="/article_assets/6.png"></p>

  <h4 id="hierarchy_and_inheritance">Иерархия и Наследование</h4>

  <p>Fabric объекты не существуют сами по себе. Они формируют чёткую иерархию.</p>

  <p>Большинство объектов наследуют от <code>fabric.Object</code>. <code>fabric.Object</code> олицетворяет 2-х мерную фигуру на плоскости. Это нечто имеющее left/top и width/height атрибуты, а также набор других визуальных параметров. Те атрибуты которые мы видели ранее &mdash; fill, stroke, angle, opacity, flip*, и т.д. &mdash; они принадлежат всем Fabric объектам которые наследуют от <code>fabric.Object</code>.</p>

  <p>Такое наследование очень удобно. Оно позволяет нам определить методы на <code>fabric.Object</code> что автоматически "переносит" их на все "классы" потомки. Например, исли нужен метод <code>getAngleInRadians</code> на всех объектах, просто создаём его на <code>fabric.Object.prototype</code>:</p>

<pre>
fabric.Object.prototype.getAngleInRadians = function() {
  return this.getAngle() / 180 * Math.PI;
};

var rect = new fabric.Rect({ angle: 45 });
rect.getAngleInRadians(); // 0.785...

var circle = new fabric.Circle({ angle: 30, radius: 10 });
circle.getAngleInRadians(); // 0.523...

circle instanceof fabric.Circle; // true
circle instanceof fabric.Object; // true
</pre>

  <p>Как видите, метод немедленно становится доступен всем объектам.</p>

  <p>Во многих случаях, классы потомки не просто наследуют от <code>fabric.Object</code>, но ещё и имеют свои собственные методы и параметры. Например, <code>fabric.Circle</code> определяет &#8220;radius&#8221; атрибут. А <code>fabric.Image</code> &mdash; с которым мы познакомимся чуть позже &mdash; определяет <code>getElement</code>/<code>setElement</code> методы для чтения/записи HTML &lt;img> элемента, на котором основывается объект типа <code>fabric.Image</code>.</p>

  <h3 id="canvas">Canvas (холст)</h3>

  <p>Мы рассмотрели в подробности объекты; давайте опять вернёмся к canvas.</p>

  <p>Первое что видно во всех примерах, это создание самого "холста" для рисования &mdash; <code>new fabric.Canvas('...')</code>. fabric.Canvas это по сути дела оболочка вокруг &lt;canvas> елемента, ответственная за управление всеми объектами на нём. Конструктор берёт id элемента, и возвращает объект типа <code>fabric.Canvas</code>.</p>

  <p>Теперь к нему можно добавлять объекты (<code>add()</code>), а также читать (<code>item()</code>, <code>getObjects()</code>) или удалять (<code>remove()</code>):</p>

<pre>
var canvas = new fabric.Canvas('c');
var rect = new fabric.Rect();

canvas.add(rect); // добавляем

canvas.item(0); // получаем fabric.Rect добавленный ранее (первый объект)
canvas.getObjects(); // поучаем все объекты (прямоугольник будет первым и единственным)

canvas.remove(rect); // удаляем прямоугольник
</pre>

  <p>Несмотря на то что главная задача <code>fabric.Canvas</code> это управлять объектами которые на нём присутсвуют, он ещё может быть <strong>сконфигурирован</strong> через набор параметров. Хотим поменять цвет фона холста? Отсечь показ объектов по какой-то фигуре? Поменять длину/ширину? Указать если холст интерактивный или нет? Эти и другие опции можно выставить прямо на <code>fabric.Canvas</code>, во время создания или после:</p>

<pre>
var canvas = new fabric.Canvas('c', {
  backgroundColor: 'rgb(100,100,200)',
  selectionColor: 'blue',
  selectionLineWidth: 2
  // ...
});

// or

var canvas = new fabric.Canvas('c');
canvas.backgroundImage = 'http://...';
canvas.onFpsUpdate = function(){ /* ... */ };
// ...
</pre>

  <h4 id="interactivity">Интерактивность</h4>

  <p>Пока мы говорим о холсте, давайте затронем интерактивность. Одна из самых уникальных возможностей Fabric &mdash; встроеная прямо в едро &mdash; это слой интерактивности поверх той удобной объектной модели с которой мы только что ознакомились.</p>

  <p>Объектная модель существует для програмного доступа к объектам и их изменению. Но "снаружи", на уровне пользователя, мы так же можем управлять этими объектами мышкой (или тачпадом, на мобильных устройствах). Как только создаём холст через <code>new fabric.Canvas('...')</code>, сразу же можно выделять объекты, двигать их, масштабировать, вращать и даже <strong>групировать вместе</strong> и управлять как одним целым!</p>

  <p><img src="/article_assets/7.png">
  <img src="/article_assets/8.png"></p>

  <p>Если мы хотим дать возможность пользователю управлять объектами на холсте &mdash; допустим картинкой &mdash; нужно всего лишь создать холст и добавить на него объект. Больше не нужно никаких дополнительных настроек.</p>

  <p>Контролировать эту интерактивность легко. Для этого есть &#8220;selection&#8221; флаг на холсте, а также &#8220;selectable&#8221; флаг на индивидуальных объектах.</p>

<pre>
var canvas = new fabric.Canvas('c');
...
canvas.selection = false; // выключаем выделение
rect.set('selectable', false); // делаем объект невыделяемым
</pre>

  <p>Ну а что делать если интерактивность вовсе не нужна? Тогда просто меняем <code>fabric.Canvas</code> на <code>fabric.StaticCanvas</code>. Синтакс (конфигурация, методы) абсолютно идентичный; просто используем слово <code>StaticCanvas</code> вместо <code>Canvas</code>.</p>

<pre>
var staticCanvas = new fabric.StaticCanvas('c');

staticCanvas.add(
  new fabric.Rect({
    width: 10, height: 20,
    left: 100, top: 100,
    fill: 'yellow',
    angle: 30
  }));
</pre>

  <p>Это создаёт более "лёгкую" версию холста, без логики интерактивности и управления событиями. Но всё остальное остаётся таким же; всё ещё доступна <strong>полная объектная модель</strong> &mdash; можно добавлять объекты, удалять, менять, ну и конечно же менять опции самого холста. Исчезает только управление внешними событиями.</p>

  <p>Позже, когда мы ознакомимся с опцией специальной постройки Fabric (custom build), вы увидете что можно создать боле "лёгкую" версию библиотеки, если всё что нужно это StaticCanvas. Это может быть полезно если например нужно просто отобразить неинтерактивный график, или SVG фигуру, или картинки с фильтрами.</p>

  <h3 id="images">Картинки</h3>

  <p>Кстати, насчёт картинок&#8230;</p>

  <p>Всё таки работа с простыми фигурами не так интересна как с более графически насыщеными картинками. Как вы наверное уже догадываетесь, в Fabric это очень просто. Давайте создадим <code>fabric.Image</code> объект и добавим его на холст:</p>

  <p>(html)</p>

<pre>
&lt;canvas id="c">&lt;/canvas>
&lt;img src="my_image.png" id="my-image">
</pre>

  <p>(js)</p>

<pre>
var canvas = new fabric.Canvas('c');
var imgElement = document.getElementById('my-img');
var imgInstance = new fabric.Image(imgElement, {
  left: 100,
  top: 100,
  angle: 30,
  opacity: 0.85
});
canvas.add(imgInstance);
</pre>

  <p>Заметьте как мы передаём &lt;image> елемент в <code>fabric.Image</code> конструктор. Это создаёт объект типа <code>fabric.Image</code> который представляет из себя картинку с этого элемента. Мы также выставляем left/top значения на 100/100, угол на 30, и прозрачность на 0.85. После добавления на холст, картинка рендерится в позиции 100,100, повёрнута на 30 градусов, и слегка прозрачна! Неплохо...</p>

  <p><img src="/article_assets/9.png"></p>

  <p>А что же делать если картинки в документе не существует; если есть только её адрес? Это не страшно. В таком случае можно использовать <code>fabric.Image.fromURL</code>:</p>

<pre>
fabric.Image.fromURL('my_image.png', function(oImg) {
  canvas.add(oImg);
});
</pre>

  <p>Наверное понятно и так. Вызываем <code>fabric.Image.fromURL</code> передавая адрес картинки, а также указываем функцию (callback), которую надо вызвать когда картинка загрузится. Функция обратного вызова получает в себя <code>fabric.Image</code> объект как первый аргумент. В тот момент можно делать с ней что угодно — изменить или сразу добавить для показа:</p>

<pre>
fabric.Image.fromURL('my_image.png', function(oImg) {
  // уменьшаем картинку и переварачиваем перед добавлением
  oImg.scale(0.5).setFlipX(true);
  canvas.add(oImg);
});
</pre>

  <h3 id="path_and_pathgroup">Path и PathGroup</h3>

  <p>Мы ознакомились с простыми фигурами и картинками. Ну а что насчёт более сложного контента?</p>

  <p>Встречайте мощную и незаменимую пару &mdash; Path и PathGroup.</p>

  <p>Path в Fabric представляют из себя кривую фигуру которая может быть залита цветом, иметь контур, и быть изменённой любым способом. Они состоят из набора команд, которые по сути дела имитируют ручку рисующую от одной точки до другой. При помощи таких команд как &#8220;move&#8221; (двинуть), &#8220;line&#8221; (линия), &#8220;curve&#8221; (кривая), или &#8220;arc&#8221; (арка), Path могут воспроизводить удивительно сложные фигуры. А с помощью Path груп (PathGroup), нет ничего невозможного.</p>

  <p>Paths (контуры) в Fabric имеют сходство с <a href="http://www.w3.org/TR/SVG/paths.html#PathElement">SVG &lt;path> элементами</a>. Они используют такой же набор комманд, могут быть созданы из &lt;path> элементов, и сериализованы в них. О сериализации и SVG парсинге мы поговорим позже. Сейчас стоит сказать что работать с Path объектами вы врядли будете вручную. Вместо этого имеет смысл использовать SVG парсер встроенный в Fabric. Но чтобы понять что же из себя представляют эти Path объекты, давайте создадим один из них:</p>

<pre>
var canvas = new fabric.Canvas('c');
var path = new fabric.Path('M 0 0 L 200 100 L 170 200 z');
path.set({ left: 120, top: 120 });
canvas.add(path);
</pre>

  <p><img src="/article_assets/10.png"></p>

  <p>При создании <code>fabric.Path</code> объекта, мы передаём строку с инструкциями контура. Выглядит эта инструкция конечно очень загадочно, но понять её на самом деле довольно легко. &#8220;M&#8221; означает &#8220;move&#8221; (двинуть) команду, и говорит невидимой ручке подвинуться в точку 0, 0. &#8220;L&#8221; означает &#8220;line&#8221; (линия) и рисует линию до точки 200, 100. Затем, ещё одна &#8220;L&#8221; команда рисует линию до 170, 200. И наконец, &#8220;z&#8221; заставляет невидимую ручку "закрыть" текущий контур и финализировать фигуру. Как результат, получается вот такая треугольная форма.</p>

  <p>Так как <code>fabric.Path</code> объект — такой же объект как и остальные в Fabric, мы смогли легко изменить его параметры (left, top). Но можно изменить ещё больше:</p>

<pre>
...
var path = new fabric.Path('M 0 0 L 300 100 L 200 300 z');
...
path.set({ fill: 'red', stroke: 'green', opacity: 0.5 });
canvas.add(path);
</pre>

  <p><img src="/article_assets/11.png"></p>

  <p>Ради интереса, давайте посмотрим на ещё один контур; на этот раз более сложный. Вы поймёте почему создание контуров вручную — не самое весёлое занятие.</p>

<pre>
...
var path = new fabric.Path('M121.32,0L44.58,0C36.67,0,29.5,3.22,24.31,8.41\
c-5.19,5.19-8.41,12.37-8.41,20.28c0,15.82,12.87,28.69,28.69,28.69c0,0,4.4,\
0,7.48,0C36.66,72.78,8.4,101.04,8.4,101.04C2.98,106.45,0,113.66,0,121.32\
c0,7.66,2.98,14.87,8.4,20.29l0,0c5.42,5.42,12.62,8.4,20.28,8.4c7.66,0,14.87\
-2.98,20.29-8.4c0,0,28.26-28.25,43.66-43.66c0,3.08,0,7.48,0,7.48c0,15.82,\
12.87,28.69,28.69,28.69c7.66,0,14.87-2.99,20.29-8.4c5.42-5.42,8.4-12.62,8.4\
-20.28l0-76.74c0-7.66-2.98-14.87-8.4-20.29C136.19,2.98,128.98,0,121.32,0z');

canvas.add(path.set({ left: 100, top: 200 }));
</pre>

  <p>Огого, что же здесь происходит?! Давайте разбираться.</p>

  <p>&#8220;M&#8221; всё ещё означает &#8220;move&#8221; (двинуть) команду, и вот невидимая ручка начинает своё путешествие от точки &#8220;121.32, 0&#8221;. Затем, &#8220;L&#8221; команда, которая приводит её к точке &#8220;44.58, 0&#8221;. Пока всё просто. А что следующее? &#8220;C&#8221; команда, которая означает &#8220;cubic bezier&#8221; (<a href="http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%91%D0%B5%D0%B7%D1%8C%D0%B5">кривая безье</a>). Она принуждает ручку рисовать кривую в точку &#8220;36.67, 0&#8221;. Кривая использует &#8220;29.5, 3.22&#8221; как точку контроля в начале линии, и &#8220;24.31, 8.41&#8221; как точку контроля в конце линии. За всем этим делом идёт целая мириада остальных кривых безье, что в свою очередь и создаёт финальную фигуру.</p>

  <p><img src="/article_assets/12.png"></p>

  <p>С такими "монстрами" вручную работать вы наверняка не будете. Вместо этого, можно использовать очень удобный метод <code>fabric.loadSVGFromString</code> или <code>fabric.loadSVGFromURL</code>, загружая целый SVG файл. Всё остальное сделает парсер Fabric, пройдя по всем SVG элементам и создавая соответствующие Path объекты.</p>

  <p>Кстати насчёт SVG документов, Path в Fabric обычно представляет SVG &lt;path> элемент, а вот набор таких элементов — что очень часто можно найти в SVG документах — обычно представлены через PathGroup (<code>fabric.PathGroup</code> объекты). PathGroup это всего лишь група Path объектов (кривых). И так как <code>fabric.PathGroup</code> наследует от <code>fabric.Object</code>, такие объекты могут быть добавлены на холст как и любые другие объекты Fabric. И конечно же ими можно управлять как и всем остальным.</p>

  <p>Напрямую с ними работать скорее всего не придётся. Но если они вам попадутся во время работы с Fabric — будете знать с чем имеете дело, и зачем они вообще нужны.</p>

  <h3 id="afterword">Послесловие</h3>

  <p>Мы затронули только самые базовые аспекты Fabric. Теперь вы с лёгкостью сможете создать как простые так и сложные фигуры или картинки; показать их на холсте, менять их как угодно — позицию, масштаб, угол, цвета, контуры, прозрачность — всё что душа пожелает.</p>

  <p>В следующей части, мы поговорим о работе с групами, анимации, тексте, SVG парсинге, рендеринге и сериализации, управлении событиями, фильтрами картинок, и остальных интересных вещах.</p>

  <p>А пока взгляните на <a href="http://fabricjs.com/demos/">демки с объяснительным кодом</a> или <a href="http://fabricjs.com/benchmarks/">бенчмарки</a>, присоединяйтесь к дискусии в <a href="https://groups.google.com/forum/?fromgroups#!forum/fabricjs">google group</a> или <a href="http://stackoverflow.com/questions/tagged/fabricjs">Stackoverflow</a>, или ознакомтесь с <a href="http://fabricjs.com/docs/">документацией</a>, <a href="https://github.com/kangax/fabric.js/wiki">wiki</a>, и <a href="https://github.com/kangax/fabric.js">кодом</a>.</p>

  <p>Я надеюсь вам понравится экспериментировать с Fabric!</p>

  Читайте <a href="/fabric-intro-part-2">Часть 2</a>.

</div>